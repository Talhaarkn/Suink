import "./chunk-BM5COPPE.js";
import {
  Transaction
} from "./chunk-36S6Z67S.js";
import {
  Ed25519Keypair,
  PublicKey,
  SIGNATURE_SCHEME_TO_FLAG,
  Signer,
  ZkLoginPublicIdentifier,
  bytesEqual,
  decodeJwt,
  decodeSuiPrivateKey,
  getZkLoginSignature,
  parseSerializedSignature
} from "./chunk-4K6GDM3H.js";
import "./chunk-PWHBBEXE.js";
import "./chunk-AMANTD2Z.js";
import {
  fromBase64,
  toBase64
} from "./chunk-H277EU3U.js";
import {
  ReadonlyWalletAccount,
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
  WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED,
  WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND,
  WalletStandardError,
  getWallets,
  mitt_default,
  safeCaptureStackTrace
} from "./chunk-N3ZDKMQZ.js";
import {
  Field,
  _normFnElement,
  bytesToNumberBE,
  createCurve,
  createHasher as createHasher2,
  ensureBytes,
  inRange,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  mod,
  numberToBytesBE,
  pow2,
  secp256r1,
  sha256,
  sha2562
} from "./chunk-6WJISZEV.js";
import {
  Chi,
  HashMD,
  Maj,
  clean,
  concatBytes,
  createHasher,
  randomBytes,
  rotl,
  utf8ToBytes
} from "./chunk-5ZNDD6DZ.js";
import {
  createBase58check
} from "./chunk-7OJVVFNS.js";
import "./chunk-WOOG5QLI.js";

// node_modules/@mysten/enoki/dist/esm/EnokiClient/index.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _version;
var _apiUrl;
var _apiKey;
var _EnokiClient_instances;
var fetch_fn;
var DEFAULT_API_URL = "https://api.enoki.mystenlabs.com";
var ZKLOGIN_HEADER = "zklogin-jwt";
var EnokiClientError = class extends Error {
  constructor(status, response) {
    var _a;
    let errors;
    try {
      const parsedResponse = JSON.parse(response);
      errors = parsedResponse.errors;
    } catch (e) {
    }
    const cause = (errors == null ? void 0 : errors[0]) ? new Error(errors[0].message) : void 0;
    super(`Request to Enoki API failed (status: ${status})`, {
      cause
    });
    this.errors = [];
    this.errors = errors ?? [];
    this.name = "EnokiClientError";
    this.status = status;
    this.code = ((_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.code) ?? "unknown_error";
  }
};
var EnokiClient = class {
  constructor(config) {
    __privateAdd(this, _EnokiClient_instances);
    __privateAdd(this, _version);
    __privateAdd(this, _apiUrl);
    __privateAdd(this, _apiKey);
    __privateSet(this, _version, "v1");
    __privateSet(this, _apiUrl, config.apiUrl ?? DEFAULT_API_URL);
    __privateSet(this, _apiKey, config.apiKey);
  }
  getApp(_input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "app", {
      method: "GET"
    });
  }
  getZkLogin(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin", {
      method: "GET",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      }
    });
  }
  getZkLoginAddresses(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/addresses", {
      method: "GET",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      }
    });
  }
  createZkLoginNonce(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/nonce", {
      method: "POST",
      body: JSON.stringify({
        network: input.network,
        ephemeralPublicKey: input.ephemeralPublicKey.toSuiPublicKey(),
        additionalEpochs: input.additionalEpochs
      })
    });
  }
  createZkLoginZkp(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/zkp", {
      method: "POST",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      },
      body: JSON.stringify({
        network: input.network,
        ephemeralPublicKey: input.ephemeralPublicKey.toSuiPublicKey(),
        maxEpoch: input.maxEpoch,
        randomness: input.randomness
      })
    });
  }
  createSponsoredTransaction(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "transaction-blocks/sponsor", {
      method: "POST",
      headers: input.jwt ? {
        [ZKLOGIN_HEADER]: input.jwt
      } : {},
      body: JSON.stringify({
        sender: input.sender,
        network: input.network,
        transactionBlockKindBytes: input.transactionKindBytes,
        allowedAddresses: input.allowedAddresses,
        allowedMoveCallTargets: input.allowedMoveCallTargets
      })
    });
  }
  executeSponsoredTransaction(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, `transaction-blocks/sponsor/${input.digest}`, {
      method: "POST",
      body: JSON.stringify({
        signature: input.signature
      })
    });
  }
  getSubnames(input) {
    const query = new URLSearchParams();
    if (input.address) {
      query.set("address", input.address);
    }
    if (input.network) {
      query.set("network", input.network);
    }
    if (input.domain) {
      query.set("domain", input.domain);
    }
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames" + (query.size > 0 ? `?${query.toString()}` : ""), {
      method: "GET"
    });
  }
  createSubname(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames", {
      method: "POST",
      headers: input.jwt ? {
        [ZKLOGIN_HEADER]: input.jwt
      } : {},
      body: JSON.stringify({
        network: input.network,
        domain: input.domain,
        subname: input.subname,
        targetAddress: input.targetAddress
      })
    });
  }
  deleteSubname(input) {
    __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames", {
      method: "DELETE",
      body: JSON.stringify({
        network: input.network,
        domain: input.domain,
        subname: input.subname
      })
    });
  }
};
_version = /* @__PURE__ */ new WeakMap();
_apiUrl = /* @__PURE__ */ new WeakMap();
_apiKey = /* @__PURE__ */ new WeakMap();
_EnokiClient_instances = /* @__PURE__ */ new WeakSet();
fetch_fn = async function(path, init) {
  const res = await fetch(`${__privateGet(this, _apiUrl)}/${__privateGet(this, _version)}/${path}`, {
    ...init,
    headers: {
      ...init.headers,
      Authorization: `Bearer ${__privateGet(this, _apiKey)}`,
      "Content-Type": "application/json",
      "Request-Id": crypto.randomUUID()
    }
  });
  if (!res.ok) {
    throw new EnokiClientError(res.status, await res.text());
  }
  const { data } = await res.json();
  return data;
};

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n, P) * b3 % P;
  const b9 = pow2(b6, _3n, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y) => y % _2n === _0n;
function schnorrGetExtPubKey(priv) {
  const { Fn, BASE } = Pointk1;
  const d_ = _normFnElement(Fn, priv);
  const p = BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp = Fpk1;
  if (!Fp.isValidNot0(x))
    throw new Error("invalid x: Fail if x â‰¥ p");
  const xx = Fp.create(x * x);
  const c = Fp.create(xx * x + BigInt(7));
  let y = Fp.sqrt(c);
  if (!hasEven(y))
    y = Fp.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn } = Pointk1;
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn, BASE } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n, secp256k1_CURVE.n))
      return false;
    const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      MD5_W[i] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i = 0; i < 64; i++) {
      let F, g, s;
      if (i < 16) {
        F = Chi(B, C, D);
        g = i;
        s = [7, 12, 17, 22];
      } else if (i < 32) {
        F = Chi(D, B, C);
        g = (5 * i + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i < 48) {
        F = B ^ C ^ D;
        g = (3 * i + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i % 16;
        s = [6, 10, 15, 21];
      }
      F = F + A + K[i] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s[i % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");

// node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/signers/dist/esm/webcrypto/index.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _publicKey;
function getCompressedPublicKey(publicKey) {
  const rawBytes = new Uint8Array(publicKey);
  const x = rawBytes.slice(1, 33);
  const y = rawBytes.slice(33, 65);
  const prefix = (y[31] & 1) === 0 ? 2 : 3;
  const compressed = new Uint8Array(Secp256r1PublicKey.SIZE);
  compressed[0] = prefix;
  compressed.set(x, 1);
  return compressed;
}
var _WebCryptoSigner = class _WebCryptoSigner2 extends Signer {
  constructor(privateKey, publicKey) {
    super();
    __privateAdd2(this, _publicKey);
    this.privateKey = privateKey;
    __privateSet2(this, _publicKey, new Secp256r1PublicKey(publicKey));
  }
  static async generate({ extractable = false } = {}) {
    const keypair = await globalThis.crypto.subtle.generateKey(
      {
        name: "ECDSA",
        namedCurve: "P-256"
      },
      extractable,
      ["sign", "verify"]
    );
    const publicKey = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
    return new _WebCryptoSigner2(
      keypair.privateKey,
      getCompressedPublicKey(new Uint8Array(publicKey))
    );
  }
  /**
   * Imports a keypair using the value returned by `export()`.
   */
  static import(data) {
    return new _WebCryptoSigner2(data.privateKey, data.publicKey);
  }
  getKeyScheme() {
    return "Secp256r1";
  }
  /**
   * Exports the keypair so that it can be stored in IndexedDB.
   */
  export() {
    const exportedKeypair = {
      privateKey: this.privateKey,
      publicKey: __privateGet2(this, _publicKey).toRawBytes()
    };
    Object.defineProperty(exportedKeypair, "toJSON", {
      enumerable: false,
      value: () => {
        throw new Error(
          "The exported keypair must not be serialized. It must be stored in IndexedDB directly."
        );
      }
    });
    return exportedKeypair;
  }
  getPublicKey() {
    return __privateGet2(this, _publicKey);
  }
  async sign(bytes) {
    const rawSignature = await globalThis.crypto.subtle.sign(
      {
        name: "ECDSA",
        hash: "SHA-256"
      },
      this.privateKey,
      bytes
    );
    const signature = secp256r1.Signature.fromCompact(new Uint8Array(rawSignature));
    return signature.normalizeS().toCompactRawBytes();
  }
};
_publicKey = /* @__PURE__ */ new WeakMap();
var WebCryptoSigner = _WebCryptoSigner;

// node_modules/@mysten/sui/dist/esm/zklogin/address.js
var MAX_PADDED_UNSIGNED_JWT_LEN = 64 * 25;

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}

// node_modules/nanostores/task/index.js
var tasks = 0;
var resolves = [];
function startTask() {
  tasks += 1;
  return () => {
    tasks -= 1;
    if (tasks === 0) {
      let prevResolves = resolves;
      resolves = [];
      for (let i of prevResolves) i();
    }
  };
}
function task(cb) {
  let endTask = startTask();
  let promise = cb().finally(endTask);
  promise.t = true;
  return promise;
}
function allTasks() {
  if (tasks === 0) {
    return Promise.resolve();
  } else {
    return new Promise((resolve) => {
      resolves.push(resolve);
    });
  }
}

// node_modules/nanostores/clean-stores/index.js
var clean2 = Symbol("clean");

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean2] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/nanostores/lifecycle/index.js
var SET = 2;
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var onSet = ($store, listener) => on($store, listener, SET, (runListeners) => {
  let originSet = $store.set;
  let originSetKey = $store.setKey;
  if ($store.setKey) {
    $store.setKey = (changed, changedValue) => {
      let isAborted;
      let abort = () => {
        isAborted = true;
      };
      runListeners({
        abort,
        changed,
        newValue: { ...$store.value, [changed]: changedValue }
      });
      if (!isAborted) return originSetKey(changed, changedValue);
    };
  }
  $store.set = (newValue) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, newValue });
    if (!isAborted) return originSet(newValue);
  };
  return () => {
    $store.set = originSet;
    $store.setKey = originSetKey;
  };
});
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy) $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT]) destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean2];
      $store[clean2] = () => {
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// node_modules/@mysten/enoki/dist/esm/encryption.js
function createDefaultEncryption() {
  async function keyFromPassword(password, salt) {
    const key = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(password),
      { name: "PBKDF2" },
      false,
      ["deriveBits", "deriveKey"]
    );
    const derivedKey = await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 9e5,
        hash: "SHA-256"
      },
      key,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    return { key, derivedKey };
  }
  return {
    async encrypt(password, data) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const { derivedKey } = await keyFromPassword(password, salt);
      const payload = await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv
        },
        derivedKey,
        new TextEncoder().encode(data)
      );
      return JSON.stringify({
        payload: toBase64(new Uint8Array(payload)),
        iv: toBase64(iv),
        salt: toBase64(salt)
      });
    },
    async decrypt(password, data) {
      const parsed = JSON.parse(data);
      if (!parsed.payload || !parsed.iv || !parsed.salt) {
        throw new Error("Invalid encrypted data");
      }
      const { derivedKey } = await keyFromPassword(password, fromBase64(parsed.salt));
      const decryptedContent = await crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: fromBase64(parsed.iv)
        },
        derivedKey,
        fromBase64(parsed.payload)
      );
      return new TextDecoder().decode(decryptedContent);
    }
  };
}

// node_modules/@mysten/enoki/dist/esm/EnokiKeypair.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _proof;
var _maxEpoch;
var _ephemeralKeypair;
var _publicKey2;
var EnokiPublicKey = class extends ZkLoginPublicIdentifier {
};
var EnokiKeypair = class extends Signer {
  constructor(input) {
    super();
    __privateAdd3(this, _proof);
    __privateAdd3(this, _maxEpoch);
    __privateAdd3(this, _ephemeralKeypair);
    __privateAdd3(this, _publicKey2);
    __privateSet3(this, _proof, input.proof);
    __privateSet3(this, _maxEpoch, input.maxEpoch);
    __privateSet3(this, _ephemeralKeypair, input.ephemeralKeypair);
    __privateSet3(this, _publicKey2, EnokiPublicKey.fromProof(input.address, input.proof));
  }
  async sign(data) {
    return __privateGet3(this, _ephemeralKeypair).sign(data);
  }
  async signPersonalMessage(bytes) {
    const { bytes: signedBytes, signature: userSignature } = await __privateGet3(this, _ephemeralKeypair).signPersonalMessage(bytes);
    const zkSignature = getZkLoginSignature({
      inputs: __privateGet3(this, _proof),
      maxEpoch: __privateGet3(this, _maxEpoch),
      userSignature
    });
    return {
      bytes: signedBytes,
      signature: zkSignature
    };
  }
  async signTransaction(bytes) {
    const { bytes: signedBytes, signature: userSignature } = await __privateGet3(this, _ephemeralKeypair).signTransaction(bytes);
    const zkSignature = getZkLoginSignature({
      inputs: __privateGet3(this, _proof),
      maxEpoch: __privateGet3(this, _maxEpoch),
      userSignature
    });
    return {
      bytes: signedBytes,
      signature: zkSignature
    };
  }
  getKeyScheme() {
    return __privateGet3(this, _ephemeralKeypair).getKeyScheme();
  }
  getPublicKey() {
    return __privateGet3(this, _publicKey2);
  }
};
_proof = /* @__PURE__ */ new WeakMap();
_maxEpoch = /* @__PURE__ */ new WeakMap();
_ephemeralKeypair = /* @__PURE__ */ new WeakMap();
_publicKey2 = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/enoki/dist/esm/stores.js
function createWebStorage(storage) {
  return {
    get(key) {
      return storage.getItem(key);
    },
    set(key, value) {
      storage.setItem(key, value);
    },
    delete(key) {
      storage.removeItem(key);
    }
  };
}
function createInMemoryStorage() {
  const store = /* @__PURE__ */ new Map();
  return {
    get(key) {
      return store.get(key) ?? null;
    },
    set(key, value) {
      store.set(key, value);
    },
    delete(key) {
      store.delete(key);
    }
  };
}
function createLocalStorage() {
  if (typeof window === "undefined") {
    console.warn("`window.localStorage` is not available, falling back to in-memory storage");
    return createInMemoryStorage();
  }
  return createWebStorage(window.localStorage);
}
function createSessionStorage() {
  if (typeof window === "undefined") {
    console.warn("`window.sessionStorage` is not available, falling back to in-memory storage");
    return createInMemoryStorage();
  }
  return createWebStorage(window.sessionStorage);
}

// node_modules/@mysten/enoki/dist/esm/EnokiFlow.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _storageKeys;
var _enokiClient;
var _encryption;
var _encryptionKey;
var _store;
var _useNativeCryptoSigner;
var _idbStore;
var _EnokiFlow_instances;
var setSession_fn;
var createStorageKeys = (apiKey) => ({
  STATE: `@enoki/flow/state/${apiKey}`,
  SESSION: `@enoki/flow/session/${apiKey}`
});
var EnokiFlow = class {
  constructor(config) {
    __privateAdd4(this, _EnokiFlow_instances);
    __privateAdd4(this, _storageKeys);
    __privateAdd4(this, _enokiClient);
    __privateAdd4(this, _encryption);
    __privateAdd4(this, _encryptionKey);
    __privateAdd4(this, _store);
    __privateAdd4(this, _useNativeCryptoSigner);
    __privateAdd4(this, _idbStore);
    __privateSet4(this, _enokiClient, new EnokiClient({
      apiKey: config.apiKey,
      apiUrl: config.apiUrl
    }));
    __privateSet4(this, _encryptionKey, config.apiKey);
    if (config.experimental_nativeCryptoSigner) {
      __privateSet4(this, _useNativeCryptoSigner, true);
      __privateSet4(this, _idbStore, createStore(config.apiKey, "enoki"));
    } else {
      __privateSet4(this, _useNativeCryptoSigner, false);
    }
    __privateSet4(this, _encryption, config.encryption ?? createDefaultEncryption());
    __privateSet4(this, _store, config.store ?? createSessionStorage());
    __privateSet4(this, _storageKeys, createStorageKeys(config.apiKey));
    let storedState = null;
    try {
      const rawStoredValue = __privateGet4(this, _store).get(__privateGet4(this, _storageKeys).STATE);
      if (rawStoredValue) {
        storedState = JSON.parse(rawStoredValue);
      }
    } catch {
    }
    this.$zkLoginState = atom(storedState || {});
    this.$zkLoginSession = atom({ initialized: false, value: null });
    onMount(this.$zkLoginSession, () => {
      this.getSession();
    });
    onSet(this.$zkLoginState, ({ newValue }) => {
      __privateGet4(this, _store).set(__privateGet4(this, _storageKeys).STATE, JSON.stringify(newValue));
    });
  }
  get enokiClient() {
    return __privateGet4(this, _enokiClient);
  }
  async createAuthorizationURL(input) {
    const ephemeralKeyPair = __privateGet4(this, _useNativeCryptoSigner) ? await WebCryptoSigner.generate() : new Ed25519Keypair();
    const { nonce, randomness, maxEpoch, estimatedExpiration } = await __privateGet4(this, _enokiClient).createZkLoginNonce({
      network: input.network,
      ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
    });
    const params = new URLSearchParams({
      ...input.extraParams,
      nonce,
      client_id: input.clientId,
      redirect_uri: input.redirectUrl,
      response_type: "id_token",
      // TODO: Eventually fetch the scopes for this client ID from the Enoki service:
      scope: [
        "openid",
        // Merge the requested scopes in with the required openid scopes:
        ...input.extraParams && "scope" in input.extraParams ? input.extraParams.scope : []
      ].filter(Boolean).join(" ")
    });
    let oauthUrl;
    switch (input.provider) {
      case "google": {
        oauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
        break;
      }
      case "facebook": {
        oauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;
        break;
      }
      case "twitch": {
        params.set("force_verify", "true");
        oauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;
        break;
      }
      default:
        throw new Error(`Invalid provider: ${input.provider}`);
    }
    this.$zkLoginState.set({ provider: input.provider });
    if (__privateGet4(this, _useNativeCryptoSigner)) {
      await set("ephemeralKeyPair", ephemeralKeyPair.export(), __privateGet4(this, _idbStore));
    }
    await __privateMethod2(this, _EnokiFlow_instances, setSession_fn).call(this, {
      expiresAt: estimatedExpiration,
      maxEpoch,
      randomness,
      ephemeralKeyPair: __privateGet4(this, _useNativeCryptoSigner) ? "@@native" : toBase64(
        decodeSuiPrivateKey(ephemeralKeyPair.getSecretKey()).secretKey
      )
    });
    return oauthUrl;
  }
  // TODO: Should our SDK manage this automatically in addition to exposing a method?
  async handleAuthCallback(hash = window.location.hash) {
    const params = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
    const zkp = await this.getSession();
    if (!zkp || !zkp.ephemeralKeyPair || !zkp.maxEpoch || !zkp.randomness) {
      throw new Error(
        "Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this."
      );
    }
    const jwt = params.get("id_token");
    if (!jwt) {
      throw new Error("Missing ID Token");
    }
    decodeJwt(jwt);
    const { address, salt, publicKey } = await __privateGet4(this, _enokiClient).getZkLogin({ jwt });
    this.$zkLoginState.set({
      ...this.$zkLoginState.get(),
      salt,
      address,
      publicKey
    });
    await __privateMethod2(this, _EnokiFlow_instances, setSession_fn).call(this, {
      ...zkp,
      jwt
    });
    return params.get("state");
  }
  async getSession() {
    if (this.$zkLoginSession.get().initialized) {
      return this.$zkLoginSession.get().value;
    }
    try {
      const storedValue = __privateGet4(this, _store).get(__privateGet4(this, _storageKeys).SESSION);
      if (!storedValue) return null;
      const state = JSON.parse(
        await __privateGet4(this, _encryption).decrypt(__privateGet4(this, _encryptionKey), storedValue)
      );
      if ((state == null ? void 0 : state.expiresAt) && Date.now() > state.expiresAt) {
        await this.logout();
      } else {
        this.$zkLoginSession.set({ initialized: true, value: state });
      }
    } catch {
      this.$zkLoginSession.set({ initialized: true, value: null });
    }
    return this.$zkLoginSession.get().value;
  }
  async logout() {
    this.$zkLoginState.set({});
    __privateGet4(this, _store).delete(__privateGet4(this, _storageKeys).STATE);
    if (__privateGet4(this, _useNativeCryptoSigner)) {
      await clear(__privateGet4(this, _idbStore));
    }
    await __privateMethod2(this, _EnokiFlow_instances, setSession_fn).call(this, null);
  }
  // TODO: Should this return the proof if it already exists?
  async getProof({ network } = {}) {
    const zkp = await this.getSession();
    const { salt } = this.$zkLoginState.get();
    if (zkp == null ? void 0 : zkp.proof) {
      if (zkp.expiresAt && Date.now() > zkp.expiresAt) {
        throw new Error("Stored proof is expired.");
      }
      return zkp.proof;
    }
    if (!salt || !zkp || !zkp.jwt) {
      throw new Error("Missing required parameters for proof generation");
    }
    let storedNativeSigner = void 0;
    if (__privateGet4(this, _useNativeCryptoSigner) && zkp.ephemeralKeyPair === "@@native") {
      storedNativeSigner = await get("ephemeralKeyPair", __privateGet4(this, _idbStore));
      if (!storedNativeSigner) {
        throw new Error("Native signer not found in store.");
      }
    }
    const ephemeralKeyPair = zkp.ephemeralKeyPair === "@@native" ? WebCryptoSigner.import(storedNativeSigner) : Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));
    const proof = await __privateGet4(this, _enokiClient).createZkLoginZkp({
      network,
      jwt: zkp.jwt,
      maxEpoch: zkp.maxEpoch,
      randomness: zkp.randomness,
      ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
    });
    await __privateMethod2(this, _EnokiFlow_instances, setSession_fn).call(this, {
      ...zkp,
      proof
    });
    return proof;
  }
  async getKeypair({ network } = {}) {
    await this.getProof({ network });
    const zkp = await this.getSession();
    const { address } = this.$zkLoginState.get();
    if (!address || !zkp || !zkp.proof) {
      throw new Error("Missing required data for keypair generation.");
    }
    if (Date.now() > zkp.expiresAt) {
      throw new Error("Stored proof is expired.");
    }
    let storedNativeSigner = void 0;
    if (__privateGet4(this, _useNativeCryptoSigner) && zkp.ephemeralKeyPair === "@@native") {
      storedNativeSigner = await get("ephemeralKeyPair", __privateGet4(this, _idbStore));
      if (!storedNativeSigner) {
        throw new Error("Native signer not found in store.");
      }
    }
    const ephemeralKeypair = zkp.ephemeralKeyPair === "@@native" ? WebCryptoSigner.import(storedNativeSigner) : Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));
    return new EnokiKeypair({
      address,
      ephemeralKeypair,
      maxEpoch: zkp.maxEpoch,
      proof: zkp.proof
    });
  }
};
_storageKeys = /* @__PURE__ */ new WeakMap();
_enokiClient = /* @__PURE__ */ new WeakMap();
_encryption = /* @__PURE__ */ new WeakMap();
_encryptionKey = /* @__PURE__ */ new WeakMap();
_store = /* @__PURE__ */ new WeakMap();
_useNativeCryptoSigner = /* @__PURE__ */ new WeakMap();
_idbStore = /* @__PURE__ */ new WeakMap();
_EnokiFlow_instances = /* @__PURE__ */ new WeakSet();
setSession_fn = async function(newValue) {
  if (newValue) {
    const storedValue = await __privateGet4(this, _encryption).encrypt(
      __privateGet4(this, _encryptionKey),
      JSON.stringify(newValue)
    );
    __privateGet4(this, _store).set(__privateGet4(this, _storageKeys).SESSION, storedValue);
  } else {
    __privateGet4(this, _store).delete(__privateGet4(this, _storageKeys).SESSION);
  }
  this.$zkLoginSession.set({ initialized: true, value: newValue });
};

// node_modules/@mysten/enoki/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignTransaction.js
var SuiSignTransaction = "sui:signTransaction";

// node_modules/@mysten/enoki/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignAndExecuteTransaction.js
var SuiSignAndExecuteTransaction = "sui:signAndExecuteTransaction";

// node_modules/@mysten/enoki/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignPersonalMessage.js
var SuiSignPersonalMessage = "sui:signPersonalMessage";

// node_modules/@mysten/enoki/dist/esm/wallet/features.js
var EnokiGetMetadata = "enoki:getMetadata";
var EnokiGetSession = "enoki:getSession";

// node_modules/@mysten/enoki/dist/esm/wallet/state.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _encryption2;
var _encryptionKey2;
var _stateStore;
var _sessionContextByNetwork;
var _zkLoginState;
var _EnokiWalletState_instances;
var createZkLoginState_fn;
var sessionKey = "zklogin-session";
var stateKey = "zklogin-state";
var EnokiWalletState = class {
  constructor(config) {
    __privateAdd5(this, _EnokiWalletState_instances);
    __privateAdd5(this, _encryption2);
    __privateAdd5(this, _encryptionKey2);
    __privateAdd5(this, _stateStore);
    __privateAdd5(this, _sessionContextByNetwork);
    __privateAdd5(this, _zkLoginState);
    __privateSet5(this, _encryptionKey2, config.apiKey);
    __privateSet5(this, _encryption2, createDefaultEncryption());
    __privateSet5(this, _stateStore, createStore(`${config.apiKey}_${config.clientId}`, "enoki"));
    __privateSet5(this, _zkLoginState, __privateMethod3(this, _EnokiWalletState_instances, createZkLoginState_fn).call(this));
    __privateSet5(this, _sessionContextByNetwork, config.clients.reduce((accumulator, client) => {
      const network = client.network;
      const idbStore = createStore(`${config.apiKey}_${network}_${config.clientId}`, "enoki");
      const sessionContext = {
        $zkLoginSession: atom({ initialized: false, value: null }),
        client,
        idbStore
      };
      onMount(sessionContext.$zkLoginSession, () => {
        this.getSession(sessionContext);
      });
      return accumulator.set(network, sessionContext);
    }, /* @__PURE__ */ new Map()));
  }
  get zkLoginState() {
    return __privateGet5(this, _zkLoginState);
  }
  get sessionContextByNetwork() {
    return __privateGet5(this, _sessionContextByNetwork);
  }
  getSessionContext(network) {
    const context = __privateGet5(this, _sessionContextByNetwork).get(network);
    if (!context) {
      throw new Error(`The network ${network} isn't supported.`);
    }
    return context;
  }
  async logout() {
    __privateGet5(this, _zkLoginState).set(null);
    await clear(__privateGet5(this, _stateStore));
    for (const context of __privateGet5(this, _sessionContextByNetwork).values()) {
      await this.setSession(context, null);
      await clear(context.idbStore);
    }
  }
  async setSession(context, newValue) {
    if (newValue) {
      const storedValue = await __privateGet5(this, _encryption2).encrypt(
        __privateGet5(this, _encryptionKey2),
        JSON.stringify(newValue)
      );
      await set(sessionKey, storedValue, context.idbStore);
    } else {
      await del(sessionKey, context.idbStore);
    }
    context.$zkLoginSession.set({ initialized: true, value: newValue });
  }
  async getSession({ $zkLoginSession, idbStore }) {
    if ($zkLoginSession.get().initialized) {
      return $zkLoginSession.get().value;
    }
    try {
      const storedValue = await get(sessionKey, idbStore);
      if (!storedValue) return null;
      const state = JSON.parse(
        await __privateGet5(this, _encryption2).decrypt(__privateGet5(this, _encryptionKey2), storedValue)
      );
      if ((state == null ? void 0 : state.expiresAt) && Date.now() > state.expiresAt) {
        await this.logout();
      } else {
        $zkLoginSession.set({ initialized: true, value: state });
      }
    } catch {
      $zkLoginSession.set({ initialized: true, value: null });
    }
    return $zkLoginSession.get().value;
  }
};
_encryption2 = /* @__PURE__ */ new WeakMap();
_encryptionKey2 = /* @__PURE__ */ new WeakMap();
_stateStore = /* @__PURE__ */ new WeakMap();
_sessionContextByNetwork = /* @__PURE__ */ new WeakMap();
_zkLoginState = /* @__PURE__ */ new WeakMap();
_EnokiWalletState_instances = /* @__PURE__ */ new WeakSet();
createZkLoginState_fn = function() {
  const $zkLoginState = atom(null);
  onMount($zkLoginState, () => {
    task(async () => {
      try {
        const rawStoredValue = await get(stateKey, __privateGet5(this, _stateStore));
        if (rawStoredValue) {
          $zkLoginState.set(JSON.parse(rawStoredValue));
        }
      } catch {
      }
    });
  });
  onSet($zkLoginState, ({ newValue }) => {
    set(stateKey, JSON.stringify(newValue), __privateGet5(this, _stateStore));
  });
  return $zkLoginState;
};

// node_modules/@mysten/enoki/dist/esm/wallet/wallet.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck6(obj, member, "access private method"), method);
var _events;
var _accounts;
var _name;
var _icon;
var _enokiClient2;
var _state;
var _provider;
var _clientId;
var _redirectUrl;
var _extraParams;
var _getCurrentNetwork;
var _windowFeatures;
var _signTransaction;
var _signAndExecuteTransaction;
var _signPersonalMessage;
var _getMetadata;
var _getSession;
var _on;
var _connect;
var _disconnect;
var _EnokiWallet_instances;
var getAuthorizedAccounts_fn;
var getKeypair_fn;
var getSignerContext_fn;
var createSession_fn;
var getPKCEFlowContext_fn;
var createAuthorizationURL_fn;
var handleAuthCallback_fn;
var pkceTokenExchange_fn;
var pkceFlowProviders = {
  playtron: {
    tokenEndpoint: "https://oauth2.playtron.one/oauth2/token"
  }
};
var EnokiWallet = class {
  constructor({
    name,
    icon,
    provider,
    clientId,
    redirectUrl,
    extraParams,
    windowFeatures,
    getCurrentNetwork,
    apiKey,
    apiUrl,
    clients
  }) {
    __privateAdd6(this, _EnokiWallet_instances);
    __privateAdd6(this, _events);
    __privateAdd6(this, _accounts);
    __privateAdd6(this, _name);
    __privateAdd6(this, _icon);
    __privateAdd6(this, _enokiClient2);
    __privateAdd6(this, _state);
    __privateAdd6(this, _provider);
    __privateAdd6(this, _clientId);
    __privateAdd6(this, _redirectUrl);
    __privateAdd6(this, _extraParams);
    __privateAdd6(this, _getCurrentNetwork);
    __privateAdd6(this, _windowFeatures);
    __privateAdd6(this, _signTransaction, async ({ transaction, chain, account, signal }) => {
      signal == null ? void 0 : signal.throwIfAborted();
      const { client, keypair } = await __privateMethod4(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      return keypair.signTransaction(await parsedTransaction.build({ client }));
    });
    __privateAdd6(this, _signAndExecuteTransaction, async ({
      transaction,
      chain,
      account,
      signal
    }) => {
      signal == null ? void 0 : signal.throwIfAborted();
      const { client, keypair } = await __privateMethod4(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const bytes = await parsedTransaction.build({ client });
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      const result = await keypair.signAndExecuteTransaction({
        transaction: parsedTransaction,
        client
      });
      return {
        bytes: toBase64(bytes),
        signature: result.signatures[0],
        digest: result.digest,
        effects: toBase64(result.effects.bcs)
      };
    });
    __privateAdd6(this, _signPersonalMessage, async ({ message, account, chain }) => {
      const { keypair } = await __privateMethod4(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      return keypair.signPersonalMessage(message);
    });
    __privateAdd6(this, _getMetadata, () => {
      return {
        provider: __privateGet6(this, _provider)
      };
    });
    __privateAdd6(this, _getSession, async (input) => {
      const sessionContext = __privateGet6(this, _state).getSessionContext(
        (input == null ? void 0 : input.network) ?? __privateGet6(this, _getCurrentNetwork).call(this)
      );
      return await __privateGet6(this, _state).getSession(sessionContext);
    });
    __privateAdd6(this, _on, (event, listener) => {
      __privateGet6(this, _events).on(event, listener);
      return () => __privateGet6(this, _events).off(event, listener);
    });
    __privateAdd6(this, _connect, async (input) => {
      await allTasks();
      if ((input == null ? void 0 : input.silent) || __privateGet6(this, _accounts).length > 0) {
        return { accounts: __privateGet6(this, _accounts) };
      }
      const currentNetwork = __privateGet6(this, _getCurrentNetwork).call(this);
      await __privateMethod4(this, _EnokiWallet_instances, createSession_fn).call(this, { network: currentNetwork });
      return { accounts: __privateGet6(this, _accounts) };
    });
    __privateAdd6(this, _disconnect, async () => {
      await __privateGet6(this, _state).logout();
      __privateSet6(this, _accounts, []);
      __privateGet6(this, _events).emit("change", { accounts: __privateGet6(this, _accounts) });
    });
    __privateSet6(this, _events, mitt_default());
    __privateSet6(this, _name, name);
    __privateSet6(this, _icon, icon);
    __privateSet6(this, _enokiClient2, new EnokiClient({ apiKey, apiUrl }));
    __privateSet6(this, _state, new EnokiWalletState({ apiKey, clientId, clients }));
    __privateSet6(this, _provider, provider);
    __privateSet6(this, _clientId, clientId);
    __privateSet6(this, _redirectUrl, redirectUrl || window.location.href.split("#")[0]);
    __privateSet6(this, _extraParams, extraParams);
    __privateSet6(this, _windowFeatures, windowFeatures);
    __privateSet6(this, _getCurrentNetwork, getCurrentNetwork);
    __privateSet6(this, _accounts, []);
    __privateGet6(this, _state).zkLoginState.subscribe(() => {
      __privateSet6(this, _accounts, __privateMethod4(this, _EnokiWallet_instances, getAuthorizedAccounts_fn).call(this));
      __privateGet6(this, _events).emit("change", { accounts: __privateGet6(this, _accounts) });
    });
  }
  get name() {
    return __privateGet6(this, _name);
  }
  get provider() {
    return __privateGet6(this, _provider);
  }
  get icon() {
    return __privateGet6(this, _icon);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [...__privateGet6(this, _state).sessionContextByNetwork.keys()].map(
      (network) => `sui:${network}`
    );
  }
  get accounts() {
    return __privateGet6(this, _accounts);
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: __privateGet6(this, _connect)
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: __privateGet6(this, _disconnect)
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: __privateGet6(this, _on)
      },
      [SuiSignTransaction]: {
        version: "2.0.0",
        signTransaction: __privateGet6(this, _signTransaction)
      },
      [SuiSignAndExecuteTransaction]: {
        version: "2.0.0",
        signAndExecuteTransaction: __privateGet6(this, _signAndExecuteTransaction)
      },
      [SuiSignPersonalMessage]: {
        version: "1.1.0",
        signPersonalMessage: __privateGet6(this, _signPersonalMessage)
      },
      [EnokiGetMetadata]: {
        version: "1.0.0",
        getMetadata: __privateGet6(this, _getMetadata)
      },
      [EnokiGetSession]: {
        version: "1.0.0",
        getSession: __privateGet6(this, _getSession)
      }
    };
  }
};
_events = /* @__PURE__ */ new WeakMap();
_accounts = /* @__PURE__ */ new WeakMap();
_name = /* @__PURE__ */ new WeakMap();
_icon = /* @__PURE__ */ new WeakMap();
_enokiClient2 = /* @__PURE__ */ new WeakMap();
_state = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_clientId = /* @__PURE__ */ new WeakMap();
_redirectUrl = /* @__PURE__ */ new WeakMap();
_extraParams = /* @__PURE__ */ new WeakMap();
_getCurrentNetwork = /* @__PURE__ */ new WeakMap();
_windowFeatures = /* @__PURE__ */ new WeakMap();
_signTransaction = /* @__PURE__ */ new WeakMap();
_signAndExecuteTransaction = /* @__PURE__ */ new WeakMap();
_signPersonalMessage = /* @__PURE__ */ new WeakMap();
_getMetadata = /* @__PURE__ */ new WeakMap();
_getSession = /* @__PURE__ */ new WeakMap();
_on = /* @__PURE__ */ new WeakMap();
_connect = /* @__PURE__ */ new WeakMap();
_disconnect = /* @__PURE__ */ new WeakMap();
_EnokiWallet_instances = /* @__PURE__ */ new WeakSet();
getAuthorizedAccounts_fn = function() {
  const zkLoginState = __privateGet6(this, _state).zkLoginState.get();
  if (zkLoginState) {
    return [
      new ReadonlyWalletAccount({
        address: zkLoginState.address,
        chains: this.chains,
        icon: this.icon,
        features: [SuiSignPersonalMessage, SuiSignTransaction, SuiSignAndExecuteTransaction],
        publicKey: fromBase64(zkLoginState.publicKey)
      })
    ];
  }
  return [];
};
getKeypair_fn = async function(sessionContext) {
  const session = await __privateGet6(this, _state).getSession(sessionContext);
  if (!(session == null ? void 0 : session.jwt) || Date.now() > session.expiresAt) {
    await __privateMethod4(this, _EnokiWallet_instances, createSession_fn).call(this, { network: sessionContext.client.network });
  }
  const storedNativeSigner = await get(
    "ephemeralKeyPair",
    sessionContext.idbStore
  );
  if (!storedNativeSigner) {
    throw new Error("Native signer not found in store.");
  }
  const updatedSession = await __privateGet6(this, _state).getSession(sessionContext);
  if (!(updatedSession == null ? void 0 : updatedSession.jwt)) {
    throw new Error("Failed to retrieve an active session.");
  }
  const ephemeralKeypair = WebCryptoSigner.import(storedNativeSigner);
  const proof = updatedSession.proof ?? await __privateGet6(this, _enokiClient2).createZkLoginZkp({
    network: sessionContext.client.network,
    jwt: updatedSession.jwt,
    maxEpoch: updatedSession.maxEpoch,
    randomness: updatedSession.randomness,
    ephemeralPublicKey: ephemeralKeypair.getPublicKey()
  });
  await __privateGet6(this, _state).setSession(sessionContext, { ...updatedSession, proof });
  return new EnokiKeypair({
    address: this.accounts[0].address,
    maxEpoch: updatedSession.maxEpoch,
    ephemeralKeypair,
    proof
  });
};
getSignerContext_fn = async function(chain) {
  const sessionContext = chain ? __privateGet6(this, _state).getSessionContext(chain.split(":")[1]) : null;
  if (!sessionContext) {
    throw new Error(
      `A valid Sui chain identifier was not provided in the request. Please report this issue to the dApp developer. Examples of valid Sui chain identifiers are 'sui:testnet' and 'sui:mainnet'. Consider using the '@mysten/dapp-kit' package, which provides this value automatically.`
    );
  }
  const keypair = await __privateMethod4(this, _EnokiWallet_instances, getKeypair_fn).call(this, sessionContext);
  return { client: sessionContext.client, keypair };
};
createSession_fn = async function({ network }) {
  const popup = window.open(
    void 0,
    "_blank",
    typeof __privateGet6(this, _windowFeatures) === "function" ? __privateGet6(this, _windowFeatures).call(this) : __privateGet6(this, _windowFeatures)
  );
  if (!popup) {
    throw new Error("Failed to open popup");
  }
  const sessionContext = __privateGet6(this, _state).getSessionContext(network);
  const pkceContext = await __privateMethod4(this, _EnokiWallet_instances, getPKCEFlowContext_fn).call(this);
  popup.location = await __privateMethod4(this, _EnokiWallet_instances, createAuthorizationURL_fn).call(this, sessionContext, pkceContext);
  return await new Promise((resolve, reject) => {
    const interval = setInterval(() => {
      try {
        if (popup.closed) {
          clearInterval(interval);
          reject(new Error("Popup closed"));
        }
        if (!pkceContext && !popup.location.hash || pkceContext && !popup.location.search) {
          return;
        }
      } catch (e) {
        return;
      }
      clearInterval(interval);
      __privateMethod4(this, _EnokiWallet_instances, handleAuthCallback_fn).call(this, {
        hash: popup.location.hash,
        sessionContext,
        search: popup.location.search,
        pkceContext
      }).then(() => resolve(), reject);
      try {
        popup.close();
      } catch (e) {
        console.error(e);
      }
    }, 16);
  });
};
getPKCEFlowContext_fn = async function() {
  if (!pkceFlowProviders[__privateGet6(this, _provider)]) {
    return;
  }
  const array = new Uint8Array(64);
  crypto.getRandomValues(array);
  const codeVerifier = toBase64(array).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  const codeChallenge = toBase64(
    new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(codeVerifier)))
  ).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  return { codeVerifier, codeChallenge };
};
createAuthorizationURL_fn = async function(sessionContext, pkceContext) {
  const ephemeralKeyPair = await WebCryptoSigner.generate();
  const { nonce, randomness, maxEpoch, estimatedExpiration } = await __privateGet6(this, _enokiClient2).createZkLoginNonce({
    network: sessionContext.client.network,
    ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
  });
  const extraParams = typeof __privateGet6(this, _extraParams) === "function" ? __privateGet6(this, _extraParams).call(this) : __privateGet6(this, _extraParams);
  const params = new URLSearchParams({
    ...extraParams,
    nonce,
    client_id: __privateGet6(this, _clientId),
    redirect_uri: __privateGet6(this, _redirectUrl),
    response_type: "id_token",
    scope: ["openid", ...(extraParams == null ? void 0 : extraParams.scope) ? extraParams.scope.split(" ") : []].filter(Boolean).join(" "),
    ...pkceContext ? {
      response_type: "code",
      code_challenge_method: "S256",
      code_challenge: pkceContext.codeChallenge
    } : void 0
  });
  let oauthUrl;
  switch (__privateGet6(this, _provider)) {
    case "google":
      oauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
      break;
    case "facebook":
      oauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;
      break;
    case "twitch":
      params.set("force_verify", "true");
      oauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;
      break;
    case "onefc":
      oauthUrl = `https://login.onepassport.onefc.com/de3ee5c1-5644-4113-922d-e8336569a462/b2c_1a_prod_signupsignin_onesuizklogin/oauth2/v2.0/authorize?${params}`;
      break;
    case "playtron":
      oauthUrl = `https://oauth2.playtron.one/oauth2/auth?${params}`;
      break;
    default:
      throw new Error(`Invalid provider: ${__privateGet6(this, _provider)}`);
  }
  await set("ephemeralKeyPair", ephemeralKeyPair.export(), sessionContext.idbStore);
  await __privateGet6(this, _state).setSession(sessionContext, {
    expiresAt: estimatedExpiration,
    maxEpoch,
    randomness
  });
  return oauthUrl;
};
handleAuthCallback_fn = async function({
  hash,
  sessionContext,
  pkceContext,
  search
}) {
  const params = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
  const zkp = await __privateGet6(this, _state).getSession(sessionContext);
  if (!(zkp == null ? void 0 : zkp.maxEpoch) || !zkp.randomness) {
    throw new Error(
      "Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this."
    );
  }
  const jwt = pkceContext ? await __privateMethod4(this, _EnokiWallet_instances, pkceTokenExchange_fn).call(this, search, pkceContext) : params.get("id_token");
  if (!jwt) {
    throw new Error("Missing ID Token");
  }
  decodeJwt(jwt);
  const { address, publicKey } = await __privateGet6(this, _enokiClient2).getZkLogin({ jwt });
  __privateGet6(this, _state).zkLoginState.set({ address, publicKey });
  await __privateGet6(this, _state).setSession(sessionContext, { ...zkp, jwt });
  return params.get("state");
};
pkceTokenExchange_fn = async function(search, pkceContext) {
  var _a;
  const params = new URLSearchParams(search);
  const code = params.get("code");
  if (!code) {
    throw new Error("Missing code");
  }
  const tokenEndpoint = (_a = pkceFlowProviders[__privateGet6(this, _provider)]) == null ? void 0 : _a.tokenEndpoint;
  if (!tokenEndpoint) {
    throw new Error(`PKCE flow not supported for provider: ${__privateGet6(this, _provider)}`);
  }
  const response = await fetch(tokenEndpoint, {
    method: "POST",
    body: new URLSearchParams({
      grant_type: "authorization_code",
      client_id: __privateGet6(this, _clientId),
      redirect_uri: __privateGet6(this, _redirectUrl),
      code,
      code_verifier: pkceContext.codeVerifier
    })
  });
  return (await response.json()).id_token;
};

// node_modules/@mysten/enoki/dist/esm/utils.js
function isEnokiNetwork(network) {
  return network === "mainnet" || network === "testnet" || network === "devnet";
}

// node_modules/@mysten/enoki/dist/esm/wallet/providers.js
var ENOKI_PROVIDER_WALLETS_INFO = [
  {
    provider: "google",
    name: "Sign in with Google",
    icon: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMyIiB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzIgMGgtMzJ2MzJoMzJ6IiBmaWxsPSIjZmZmIi8+PGcgY2xpcC1ydWxlPSJldmVub2RkIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0yMy44Mjk5IDE2LjE4MThjMC0uNTY3Mi0uMDUwOS0xLjExMjctLjE0NTQtMS42MzYzaC03LjUzNDZ2My4wOTQ1aDQuMzA1NWMtLjE4NTUgMS0uNzQ5MSAxLjg0NzMtMS41OTY0IDIuNDE0NnYyLjAwNzNoMi41ODU1YzEuNTEyNy0xLjM5MjggMi4zODU0LTMuNDQzNyAyLjM4NTQtNS44ODAxeiIgZmlsbD0iIzQyODVmNCIvPjxwYXRoIGQ9Im0xNi4xNDk2IDI0YzIuMTYgMCAzLjk3MDktLjcxNjQgNS4yOTQ2LTEuOTM4MmwtMi41ODU1LTIuMDA3M2MtLjcxNjQuNDgtMS42MzI3Ljc2MzYtMi43MDkxLjc2MzYtMi4wODM2IDAtMy44NDczLTEuNDA3Mi00LjQ3NjQtMy4yOTgxaC0yLjY3MjcxdjIuMDcyN2MxLjMxNjQxIDIuNjE0NSA0LjAyMTgxIDQuNDA3MyA3LjE0OTExIDQuNDA3M3oiIGZpbGw9IiMzNGE4NTMiLz48cGF0aCBkPSJtMTEuNjczNSAxNy41MmMtLjE2LS40OC0uMjUwOS0uOTkyOC0uMjUwOS0xLjUyIDAtLjUyNzMuMDkwOS0xLjA0LjI1MDktMS41MnYtMi4wNzI4aC0yLjY3MjY5Yy0uNTQxODIgMS4wOC0uODUwOTEgMi4zMDE4LS44NTA5MSAzLjU5MjggMCAxLjI5MDkuMzA5MDkgMi41MTI3Ljg1MDkxIDMuNTkyN3oiIGZpbGw9IiNmYmJjMDUiLz48cGF0aCBkPSJtMTYuMTQ5NiAxMS4xODE4YzEuMTc0NSAwIDIuMjI5MS40MDM3IDMuMDU4MiAxLjE5NjRsMi4yOTQ1LTIuMjk0NmMtMS4zODU0LTEuMjkwODctMy4xOTYzLTIuMDgzNi01LjM1MjctMi4wODM2LTMuMTI3MyAwLTUuODMyNyAxLjc5MjczLTcuMTQ5MTEgNC40MDczbDIuNjcyNzEgMi4wNzI3Yy42MjkxLTEuODkwOSAyLjM5MjgtMy4yOTgyIDQuNDc2NC0zLjI5ODJ6IiBmaWxsPSIjZWE0MzM1Ii8+PC9nPjwvc3ZnPg=="
  },
  {
    provider: "facebook",
    name: "Sign in with Facebook",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgZmlsbD0iIzE4NzdGMiIgdmVyc2lvbj0iMS4wIiB2aWV3Qm94PSIwIDAgMjA4NCAyMDg0Ij48cGF0aCBkPSJNOTkyIDJDODU4LjcgOS4xIDczNi42IDM4LjEgNjE5IDkwLjVjLTI4NS41IDEyNy4yLTQ5OS4xIDM3NS45LTU4MS41IDY3Ny0yNS45IDk0LjYtMzcuOCAxOTAuMi0zNi4yIDI5MSAuOCA0Ni43IDIuOCA3NS4zIDguMyAxMTguNSAxNi4xIDEyNi42IDU2LjcgMjUxLjUgMTE4IDM2My44IDEwMS44IDE4NiAyNTYuOSAzMzYuMiA0NDUuOSA0MzEuNyA2Mi4xIDMxLjMgMTI3LjggNTYuNiAxOTMgNzQuMyA5LjkgMi43IDE5LjIgNS4yIDIwLjggNS42bDIuNy42di02OTJsLTEwNy4yLS4yLTEwNy4zLS4zdi0zMThsMTA3LjEtLjMgMTA3LjItLjIuNS05Mi44Yy41LTkwIC45LTEwMyA0LjMtMTM5LjIgMTctMTgzLjIgOTAtMzA1LjUgMjIwLjUtMzY5LjUgNTguNy0yOC44IDEyOC4zLTQ1LjcgMjE1LjktNTIuNSAyMi44LTEuOCA4Mi40LTIuNCAxMDYtMS4xIDU3LjEgMy4yIDEyMC40IDEwLjYgMTYzIDE5LjEgMTAuNyAyLjIgMjAuOSA0LjMgMjIuNSA0LjhsMyAuOC4zIDE0NC45LjIgMTQ0LjgtNi4yLS42Yy0yOS4zLTMtMTMzLjEtNC4yLTE1OC4zLTEuOS02NS42IDYtMTA4LjYgMjIuMy0xMzkgNTIuNy0yMi45IDIyLjktMzcuOCA1My00NS45IDkyLjgtNi40IDMxLjEtNy42IDUyLjgtNy42IDEzMi45djY0LjhoMTcwYzkzLjUgMCAxNzAgLjQgMTcwIC44IDAgLjUtMTMgNzEuOS0yOSAxNTguNy0xNS45IDg2LjgtMjkgMTU4LjItMjkgMTU4LjcgMCAuNC02My40LjgtMTQxIC44aC0xNDF2MzU3LjVjMCAyODUuMy4zIDM1Ny41IDEuMyAzNTcuNSAzLjMgMCA0NC43LTYuNCA2MS42LTkuNSAxNjMtMjkuOSAzMTYuNy05OC44IDQ0OS4xLTIwMS40IDU1LjgtNDMuMiAxMTMuOS05OS4xIDE1OS42LTE1My43IDQxLjMtNDkuMSA4MC41LTEwNi4yIDExMi44LTE2My45IDE5LjctMzUuMiA0Ny05My42IDYxLjctMTMyLjMgNzAuNi0xODQuOCA4Ny4yLTM4Ni4xIDQ3LjgtNTgxLjUtNDUuNy0yMjYuNi0xNjkuNC00MzUuNi0zNDYuOS01ODUuOC0xNDQuNS0xMjIuMi0zMTYuNC0yMDItNTAxLjUtMjMyLjktMzEuMy01LjItNjYuNC05LjItMTA0LTEyLTE4LjMtMS40LTk4LjctMi4xLTExOC41LTF6Ii8+PC9zdmc+"
  },
  {
    provider: "twitch",
    name: "Sign in with Twitch",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiCgl2aWV3Qm94PSItNDAwIC00MDAgMjgwMCAzMjAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj4KCTxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+CgkJLnN0MCB7CgkJCWZpbGw6ICNGRkZGRkY7CgkJfQoKCQkuc3QxIHsKCQkJZmlsbDogIzkxNDZGRjsKCQl9Cgk8L3N0eWxlPgoJPHRpdGxlPkFzc2V0IDI8L3RpdGxlPgoJPGc+CgkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIyMjAwLDEzMDAgMTgwMCwxNzAwIDE0MDAsMTcwMCAxMDUwLDIwNTAgMTA1MCwxNzAwIDYwMCwxNzAwIDYwMCwyMDAgMjIwMCwyMDAgCSIgLz4KCQk8Zz4KCQkJPGcgaWQ9IkxheWVyXzEtMiI+CgkJCQk8cGF0aCBjbGFzcz0ic3QxIiBkPSJNNTAwLDBMMCw1MDB2MTgwMGg2MDB2NTAwbDUwMC01MDBoNDAwbDkwMC05MDBWMEg1MDB6IE0yMjAwLDEzMDBsLTQwMCw0MDBoLTQwMGwtMzUwLDM1MHYtMzUwSDYwMFYyMDBoMTYwMAoJCQkJVjEzMDB6IiAvPgoJCQkJPHJlY3QgeD0iMTcwMCIgeT0iNTUwIiBjbGFzcz0ic3QxIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjYwMCIgLz4KCQkJCTxyZWN0IHg9IjExNTAiIHk9IjU1MCIgY2xhc3M9InN0MSIgd2lkdGg9IjIwMCIgaGVpZ2h0PSI2MDAiIC8+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo="
  },
  {
    provider: "onefc",
    name: "Sign in with ONE Championship",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAxmVYSWZJSSoACAAAAAcAEgEDAAEAAAABAAAAGgEFAAEAAABiAAAAGwEFAAEAAABqAAAAKAEDAAEAAAACAAAAMQECAAYAAAByAAAAEwIDAAEAAAABAAAAaYcEAAEAAAB4AAAAAAAAAEgAAAABAAAASAAAAAEAAABiZkB2MQAGAACQBwAEAAAAMDIxMAGRBwAEAAAAAQIDAACgBwAEAAAAMDEwMAGgAwABAAAA//8AAAKgBAABAAAAQAAAAAOgBAABAAAAQAAAAAAAAAAkG5CYAAAI50lEQVR4nO1YS0gVYRt+53pmzsVLaEGaYYRoihVI0IWoFt2oFroIOqBBtKgIgyJr1yraJLToYot02SI0S6WUMrppWFHmhbQ0qmN5O+d4rjPzzXzfv3j/huhvrBP+u/MsDjPfmXm/9/q87zcAaaSRRhpppJFGGmmkkUYav4BLEVlZWQAgCIIoigAgSdL8chZKT36hBIXDYZ7nBUEwTVMURVTRNuP/B3EBZWVkZITDYQAwTRNXeD5lBzkFhzH22/UFiwDHcYZh4HV+fr4gCDzP67q+UPKdsGAGMMYSiQQAuN3u2traoqKi+fPHqTaYA1JWKNUiBgBBEGRZXrx4cSgU8vv9uJKqHN4BTnouWAREUZRl2TCMrVu3ZmVlbd++HZwTeh6kaoAj/iECiLa2tng8PjExkZmZmaqQfzDY8QWO4xhjLpdL13VBEA4cOFBZWen1elVVTSQSPM97vd5IJOJ2uyORSENDQ2trq9frVRRlZGQkOzsbAPbu3dvR0SFJkq7rkiQRQo4fP75t27ZgMBiPxy9cuPD9+/ejR49WVFTIsswYi8fjsizzPE8IkSTJ4/HMzMy4XC7kg1evXtXX19vqIWUTQhwtw4QGgJUrVz569CiRSDDGLMsyTROvGWPJZNI0TcbY6OhoaWkpABw7dowxFgqFGGNNTU0oRJZlSZIWLVo0MDBgWRal9NmzZwCQl5c3Pj7OGItGo3axWpaFxszNzeFKLBajlFZXV7tcLkVRJEn624zieT47O/vx48eMMcMwULNoNDo9PT07OxsIBOxdA4FAYWEhADx8+NBWaHBwMCcnB35UwqZNmyzLQjlHjhwBgH379hFCLMuyPYLqMsYIIT9TUDgcLisrAwAMiJ1pPM87NjKv15tIJIqKijZu3BiJRDIyMt6+fVtdXU0IycjImJmZqa6uPnv2LM/zjLHh4eFAIFBaWlpRURGPx71eLwAUFBRs2LChvb0dNz548CDP85TSRCLR1taGaSkIQiQSyczMbGlp6enpoZQqimKapmEYXq/XsqxYLOZ2u0dHR4eHhwHgl8YiCMIfgtDY2IgxZYydO3cO3enxeDiOa2trY4xRSi3LQo/W1tZi9BljmqYxxi5fvoxysrKyRkdHg8EgpbSzsxMA3G73zMyM7ePNmzcLgoAKof0AgGMVPmxrzP2gbJif5dxut8vlGh4exg0MwygpKfF4PD6fDwBWrVoVi8UMwyCETExM5ObmYv7ouq7rOmPMNE1K6cjISG5ursfj2blzp61rTU0NANTU1GDCRKPRrq4uVVWRiG3t8SIzMxMvOI5De1D1v5qy9u/fj6pMTU09ePDA4/HYzjh9+rSdqTdv3gSA0tJSVJoxNjs7a6u7detWALh69SrefvjwYdmyZS6X69atW6ZpIgdomvb06dN3794NDQ0NDAy8efMmGAzeuXPnt1rZ0+6fbbh+/bpNKYcPH0YnoVeePHmCSZJIJCorK2VZPnPmDFrLGLt+/frnz58ZY7quX7lyRRCEqakpy7IIIc3NzT6fr6CgIBAIoP2EECxiu5QppXNzc9euXQMADLgoijzPY8KgB22S/G8sFEXBMKmqii8sWbJkbm4OEzqZTBYUFPh8PnwgPz8fdwqFQqOjo5g/3d3daFIwGCwqKmptbUVO7Ovrq66utiwLa6mqqorjuEOHDtmEgyCEIEElk0lcWb16NfzIcrsYfhsQkRCiaRr2mmQyyXGcaZq7d+8WBIExBgBdXV1TU1OapgFAMpk8efIkAIRCoezs7M7Ozunp6XXr1m3ZsgUlvnz5cmRkpLu7e9euXZIklZWVYfXzPD85Odnb28sY27Jli2VZmJM3btwYHx9HPxqGoapqKBRKJBLT09MAgH3Tns9/A7spYBDwHY7jWlpa0CWMMb/fL0mSoiiKovh8vu7ubrtM165dCwB1dXWUUmSVU6dOAcCaNWsmJycxo5ADKKWNjY2KouTl5WFgMVzYAXmeRzdjKf8huX+OAKUUfa9pGh4ICSEFBQXr169Hr4yNjXV1daG6lmVt2LABnW2a5tjY2MePH1VV9fv9HMdlZWXF4/HW1lae57EiN23aZJomIUSWZY7j2tvbGWN79+51u91I9uFwuLy8vLi4mDGmKArP89FoNCcnJx6PU0oNw7h9+7Ysy6Io4qz+e+ATAMBxHJJUbW0tmhSLxe7evbtixYrly5fn5ua6XK4rV64QQoLBIGOsrq7O4/GUlJTEYjFkz+bmZgBwuVwAcOLECaxI5JlwOLx06VIAuH///s8dAEUlk0m7+2qaFolELMu6du3an6kGUwhrxa70jo4OuxlFIpHBwcEvX74EAoFv374lEgmki97e3kWLFgHAxYsX2Y9Zw+/3Iz9wHFdYWBgKhWy1cDQqLy+fmpqyyc0eeHRdNwwDCx1NYozt2bMHAHA0dITdzPAkjnE8f/48etR2oX2N2r948aK4uBgA8vLy+vv78d+vX7+WlZWh+3GEvHfvns2PVVVVkiSdPn0ahyg7MvhrG4BsyxgbGhpCDsVfxxpgjImiaFebKIqaptXX14dCoeLiYhxZkRC9Xm88Huc47vXr1w0NDdgaRVF8/vx5b2+vqqrv379///49jrhYS62trTt27JAk6cOHD/39/YSQ2dnZvr6+T58++Xy+WCyGzGFZlqqqyHKojCAIPT098XgcAKLRKC7+IZf+EvMfRH6+VhQlNzd3enraMIympiYAUFUVc3oeXk/1oOM4WIsOcBTE879sput6LBbr7e2VJOnWrVuSJGGlulwuDHVK8lM2gDrA6XlseeynzwfILd3d3TMzM48ePbJHX57n8ViTknwnOFrsJMspmrbqjDE8juLt06dPL126ZBiGYRhoQzKZ/Af5TpjvTDy/ovMDdaWUqqoqy7KmaZqmqaqq6zqlVBCEVJ3ttO+CGYAaW5aFt9heMBqUUjyL2WQiiqL95F8iZQNSBcdxeLy0XYuJhOcsQogoijiMAADa4yTnt+tOBizkp0VK6f/yKdYrx3GEEEEQkEb/4ftPGmmkkUYaaaSRRhpppJHGr/gPrRmLNs+cA/AAAAAASUVORK5CYII="
  },
  {
    provider: "playtron",
    name: "Sign in with Playtron",
    icon: "data:image/png;base64,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"
  }
];

// node_modules/@mysten/enoki/dist/esm/wallet/register.js
function registerEnokiWallets({
  providers,
  windowFeatures = defaultWindowFeatures,
  ...config
}) {
  const clients = "clients" in config ? config.clients : [Object.assign(config.client, { network: config.network ?? "mainnet" })];
  const enokiCompatibleClients = clients.filter(({ network }) => isEnokiNetwork(network));
  if (enokiCompatibleClients.length === 0) {
    throw new Error("None of the specified clients are compatible with Enoki.");
  }
  const getCurrentNetwork = "clients" in config ? config.getCurrentNetwork : () => clients[0].network;
  const walletsApi = getWallets();
  const wallets = {};
  for (const { name, icon, provider } of ENOKI_PROVIDER_WALLETS_INFO) {
    const providerOptions = providers[provider];
    if (providerOptions) {
      wallets[provider] = new EnokiWallet({
        ...providerOptions,
        name,
        icon,
        provider,
        windowFeatures,
        getCurrentNetwork,
        apiKey: config.apiKey,
        apiUrl: config.apiUrl,
        clients: enokiCompatibleClients
      });
    }
  }
  const unregister = walletsApi.register(...Object.values(wallets));
  return { wallets, unregister };
}
function defaultWindowFeatures() {
  const width = 500;
  const height = 800;
  const left = (screen.width - width) / 2;
  const top = (screen.height - height) / 4;
  return `popup=1;toolbar=0;status=0;resizable=1,width=${width},height=${height},top=${top},left=${left}`;
}

// node_modules/@mysten/enoki/dist/esm/wallet/initializer.js
function enokiWalletsInitializer(options) {
  return {
    id: "enoki-wallets-initializer",
    async initialize({
      networks,
      getClient
    }) {
      const { unregister } = registerEnokiWallets({
        ...options,
        getCurrentNetwork: () => getClient().network,
        clients: networks.map(getClient)
      });
      return { unregister };
    }
  };
}

// node_modules/@wallet-standard/ui-registry/lib/esm/UiWalletHandleRegistry_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.js
var uiWalletHandlesToWallets = /* @__PURE__ */ new WeakMap();
function getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle) {
  const wallet = uiWalletHandlesToWallets.get(uiWalletHandle);
  if (!wallet) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND);
    safeCaptureStackTrace(err, getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);
    throw err;
  }
  return wallet;
}

// node_modules/@wallet-standard/ui-features/lib/esm/getWalletFeature.js
function getWalletFeature(uiWalletHandle, featureName) {
  const wallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle);
  if (!(featureName in wallet.features)) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED, {
      featureName,
      supportedChains: [...wallet.chains],
      supportedFeatures: Object.keys(wallet.features),
      walletName: wallet.name
    });
    safeCaptureStackTrace(err, getWalletFeature);
    throw err;
  }
  return wallet.features[featureName];
}

// node_modules/@mysten/enoki/dist/esm/wallet/utils.js
function isEnokiWallet(wallet) {
  if (isWalletHandle(wallet)) {
    return wallet.features.includes(EnokiGetMetadata);
  }
  return EnokiGetMetadata in wallet.features;
}
function getWalletMetadata(wallet) {
  if (isWalletHandle(wallet)) {
    try {
      const { getMetadata } = getWalletFeature(
        wallet,
        EnokiGetMetadata
      );
      return getMetadata();
    } catch (error) {
      return null;
    }
  } else if (EnokiGetMetadata in wallet.features) {
    const walletWithFeature = wallet;
    return walletWithFeature.features[EnokiGetMetadata].getMetadata();
  }
  return null;
}
async function getSession(wallet, input) {
  if (isWalletHandle(wallet)) {
    try {
      const { getSession: getSession2 } = getWalletFeature(
        wallet,
        EnokiGetSession
      );
      return await getSession2(input);
    } catch (error) {
      return null;
    }
  } else if (EnokiGetSession in wallet.features) {
    const walletWithFeature = wallet;
    return await walletWithFeature.features[EnokiGetSession].getSession(input);
  }
  return null;
}
function isGoogleWallet(wallet) {
  var _a;
  return ((_a = getWalletMetadata(wallet)) == null ? void 0 : _a.provider) === "google";
}
function isTwitchWallet(wallet) {
  var _a;
  return ((_a = getWalletMetadata(wallet)) == null ? void 0 : _a.provider) === "twitch";
}
function isFacebookWallet(wallet) {
  var _a;
  return ((_a = getWalletMetadata(wallet)) == null ? void 0 : _a.provider) === "facebook";
}
function isWalletHandle(wallet) {
  return Array.isArray(wallet.features);
}
export {
  EnokiClient,
  EnokiClientError,
  EnokiFlow,
  EnokiKeypair,
  EnokiPublicKey,
  createDefaultEncryption,
  createInMemoryStorage,
  createLocalStorage,
  createSessionStorage,
  enokiWalletsInitializer,
  getSession,
  getWalletMetadata,
  isEnokiNetwork,
  isEnokiWallet,
  isFacebookWallet,
  isGoogleWallet,
  isTwitchWallet,
  registerEnokiWallets
};
/*! Bundled license information:

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@mysten_enoki.js.map
